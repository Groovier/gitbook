# 6.1 一切皆对象


### 1．运算符

我们知道，list是列表的类。如果用dir(list)调查list的属性，能看到一个属性是\_\_add\_\_()。从样式上看，\_\_add\_\_()是特殊方法。它特殊在哪呢？这个方法定义了“+”运算符对于list对象的意义，两个list的对象相加时，会进行合并列表的操作。结果为合并在一起的一个列表：

------------------------------------------------------------------------

    >>>print([1,2,3] + [5,6,9])   # 得到[1, 2, 3, 5, 6, 9]

------------------------------------------------------------------------

运算符，比如+、-、&gt;、&lt;、and、or等，都是通过特殊方法实现的，比如：

------------------------------------------------------------------------

    "abc" + "xyz"               # 连接字符串，获得"abcxyz"

------------------------------------------------------------------------

实际执行了如下操作：

------------------------------------------------------------------------

    "abc".__add__("xyz")

------------------------------------------------------------------------

两个对象是否能进行加法运算，首先就要看相应的对象是否有\_\_add\_\_()方法。一旦相应的对象有\_\_add\_\_()方法，即便这个对象从数学上不可加，我们也可以执行加法操作。而相对于特殊方法，功能相同的运算符更加简洁，能够简化书写。下面的一些运算用特殊方法来写会有些麻烦。

尝试下面的操作，看看效果，再想想它对应的运算符：

------------------------------------------------------------------------

    >>>(1.8).__mul__(2.0)  # 1.8*2.0
    >>>True.__or__(False)  # True or False

------------------------------------------------------------------------

这些运算相关的特殊方法还能改变执行运算的方式。比如，列表在Python中是不可以相减的。你可以测试下面的操作：

------------------------------------------------------------------------

    >>>[1,2,3] - [3,4]

------------------------------------------------------------------------

会有错误信息，说明列表对象不能进行减法操作，即列表没有定义“-”运算符。我们可以创建一个列表的子类，通过增加\_\_sub\_\_()方法，来添加减法操作的定义，例如：

------------------------------------------------------------------------

    class SuperList(list):
        def __sub__(self, b):
            a = self[:]   #由于继承于list，self可以利用[:]的引用来表示整个列表
            b = b[:]
            while len(b) > 0:
                element_b = b.pop()
                if element_b in a:
                    a.remove(element_b)
            return a
    print(SuperList([1,2,3]) - SuperList([3,4])) # 打印[1, 2]

------------------------------------------------------------------------

上面的例子中，内置函数len()用来返回列表所包含的元素的总数。内置函数\_\_sub\_\_()定义了“-”的操作：从第一个表中去掉第二个表中出现的元素。于是，我们创建的两个SuperList对象，就可以执行减法操作了。即使\_\_sub\_\_()方法已经在父类中定义过，但在子类中重新定义后，子类中的方法会覆盖父类的同名方法。即运算符将被重新定义。

定义运算符对于复杂的对象非常有用。例如，人类有多个属性，比如姓名、年龄和身高。我们可以把人类的比较（&gt;、&lt;、=）定义成只看年龄。这样就可以根据自己的目的，将原本不存在的运算增加在对象上了。如果你参加过军训，那么很可能玩过一个“向左转向右转”的游戏。当教官喊口令时，你必须要采取相反的动作。比如说听到“向左转”，就要执行向右转的动作。这个游戏中实际上就重新定义了“向左转”和“向右转”的运算符。

### 2．元素引用

下面是我们常见的表元素引用方式：

------------------------------------------------------------------------

    li = [1, 2, 3, 4, 5, 6]
    print(li[3])                  # 打印4

------------------------------------------------------------------------

上面的程序运行到li\[3\]的时候，Python发现并理解\[\]符号，然后调用\_\_getitem\_\_()方法。

------------------------------------------------------------------------

    li = [1, 2, 3, 4, 5, 6]
    print(li.__getitem__(3))    # 打印4

------------------------------------------------------------------------

看下面的操作，想想它的对应：

------------------------------------------------------------------------

    li = [1, 2, 3, 4, 5, 6]
    li.__setitem__(3, 0)
    print(li)               # 返回[1, 2, 3, 0, 5, 6]

    example_dict = {"a":1, "b":2}
    example_dict.__delitem__("a")
    print(example_dict)      # 返回{"b":2}

------------------------------------------------------------------------

### 3．内置函数的实现

与运算符类似，许多内置函数也都是调用对象的特殊方法。比如：

------------------------------------------------------------------------

    len([1,2,3])      # 返回表中元素的总数

------------------------------------------------------------------------

实际上做的是：

------------------------------------------------------------------------

    [1,2,3].__len__()

------------------------------------------------------------------------

相对于\_\_len\_\_()，内置函数len()也起到了简化书写的作用。

尝试下面的操作，想一下它的对应内置函数：

------------------------------------------------------------------------

    (-1).__abs__()
    (2.3).__int__()

------------------------------------------------------------------------
