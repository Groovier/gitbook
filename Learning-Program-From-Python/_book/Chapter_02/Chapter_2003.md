# 2.3 计算机懂选择

### 1．if结构

到现在为止，我们看到的Python程序都是指令式的。在程序中，计算机指令都按顺序执行。指令不能跳过，也不能回头重复。最早的程序都是这个样子。例如要让灯光亮十次，就要重复写十行让灯亮的指令。

为了让程序能灵活，早期的编程语言加入了“跳转”的功能。利用跳转指令，我们就能在执行过程中跳到程序中的任意一行指令继续向下执行。例如，想重复执行，就跳到前面已经执行过的某一行。程序员为了方便，频繁地在程序中向前或向后跳转。结果，程序的运行顺序看起来就像交缠在一起的面条，既难读懂，又容易出错。

程序员渐渐发现，其实跳转最主要的功能，就是选择性地执行，或者重复执行某段程序。计算机专家也论证出，只要有了“选择”和“循环”两种语法结果，“跳转”就再无必要。两种结构都能改变程序执行的流程，改变指令运行的次序。编程语言进入到结构化的时代。相对于“跳转”带来的“面条式程序”，结构化的程序变得赏心悦目。在现代编程语言中，“跳转”语法已经被彻底废除。

我们先来看选择结构的一个简单的例子。如果一个房子的售价超过50万，那么交易费率为1%，否则为2%。我们用选择结构来写一个程序。

------------------------------------------------------------------------

    total = 980000
    if total > 500000:
        transaction_rate = 0.01
    else:
        transaction_rate = 0.02
    print(transaction_rate)                # 打印0.01

------------------------------------------------------------------------

在这段程序中，出现了我们没见过的if...else...语句。其实这个语句的功能一读就懂。如果总价超过50万，那么交易费率为1%；否则，交易费率为2%。关键字if和else分别有隶属于它们的一行代码，从属代码的开头会有四个空格的缩进。程序最终会根据if后的条件是否成立，选择是执行if的从属代码，还是执行else的从属代码。总之，if结构在程序中实现了分支。

if和else后面可以跟不止一行的程序：

------------------------------------------------------------------------

    total = 980000
    if total > 500000:             # 该条件成立
        print("总价超过50万")       # 执行这一句的打印
        transaction_rate = 0.01     # 设置费率为0.01
    else:                           # else部分不执行
        print("总价不超过50万")
        transaction_rate = 0.02
    print(transaction_rate)         # 结果为0.01

------------------------------------------------------------------------

可以看到，同属于if或else的代码有四个空格的缩进。关键词if和else就像两个老大，站在行首。老大身旁还有靠后站的小弟。老大只有借着条件赢了，站在其身后的小弟才有机会亮相。最后一行print语句也站在行首，说明它和if、else两位老大平起平坐，不存在隶属关系。程序不需要条件判断，总会执行这一句。

else也并非必需的，我们可以写只有if的程序。比如：

------------------------------------------------------------------------

    total = 980000
    if total > 500000:
        print("总价超过50万")          # 条件成立，执行打印。

------------------------------------------------------------------------

没有else，实际上与空的else等价。如果if后的条件不成立，那么计算机什么都不用执行。

### 2．小弟靠后站

用缩进来表明代码的从属关系，是Python的特色。正如我们在第1章中介绍的，用缩进来标记代码关系的设计源自ABC语言。作为对比，我们可以看看C语言的写法：

------------------------------------------------------------------------

    if ( i > 0 ) {
         x = 1;
         y = 2; 
    }

------------------------------------------------------------------------

这个程序的意思是，如果变量 *i* 大于0，我们将进行括号中所包括的两个赋值操作。在C语言中，用一个花括号来表示从属于if的代码块。一般程序员也会在C语言中加入缩进，以便区分出指令的从属关系。但缩进并非强制的。下面没有缩进的代码，在C语言中也可以正常执行，与上面程序的运行结果没有任何差别：

------------------------------------------------------------------------

    if ( i > 0 ) {
    x = 1;
    y = 2; 
    }

------------------------------------------------------------------------

在Python中，同样的程序必须要写成如下形式：

------------------------------------------------------------------------

    if i > 0:
       x = 1
       y = 2

------------------------------------------------------------------------

在Python中，去掉了 ``i > 0`` 周围的括号，去除了每个语句句尾的分号，表示块的花括号也消失了。多出来了``if...``之后的:(冒号)，还有就是``x = 1`` 和 ``y = 2``前面有四个空格的缩进。通过缩进，Python识别出这两个语句是隶属于if的。为了区分出隶属关系，Python中的缩进是强制的。下面的程序，将产生完全不同的效果：

------------------------------------------------------------------------

    if i > 0:
       x = 1
    y = 2

------------------------------------------------------------------------

这里，从属于if的只有x=1这一句，第二句赋值不再归属于if。无论如何，y都会被赋值为2。

应该说，现在大部分的主流语言，如C、C++、Java、JavaScript，都是用花括号来标记程序块的，缩进也不是强制的。这一语法设计源自于流行一时的C语言。另一方面，尽管缩进不是强制的，但有经验的程序员在用这些语言写程序时，也会加入缩进，以便程序更易读。很多编辑器也有给程序自动加缩进的功能。Python的强制缩进看起来非主流，实际上只是在语法层面上执行了这一惯例，以便程序更好看，也更容易读。这种以四个空格的缩进来表示隶属关系的书写方式，还会在Python的其他语法结构中看到。

### 3．if的嵌套与elif

再回到选择结构。选择结构让程序摆脱了枯燥的指令式排列。程序的内部可以出现分支一样的结构。根据条件不同，同一个程序可以工作于多变的环境。通过elif语法和嵌套使用if，程序可以有更加丰富多彩的分支方式。

下面一个程序使用了elif结构。根据条件的不同，程序有三个分支：

------------------------------------------------------------------------

    i = 1
    if i > 0:                  # 条件1。由于i为1，这一部分将执行。
        print("positive i")
        i = i + 1
    elif i == 0:                #条件2。该部分不执行。
        print("i is 0")
        i = i*10 
    else:                       #条件3。该部分不执行。
        print("negative i")
        i = i - 1

------------------------------------------------------------------------

这里有三个块，分别由if、elif和else引领。Python先检测if的条件，如果发现if的条件为假，则跳过隶属于if的程序块，检测elif的条件；如果elif的条件还是假，则执行else块。程序根据条件，只执行三个分支中的一个。由于 *i* 的值是 *1* ，所以最终只有if部分被执行。按照同样的原理，你也可以在if和else之间增加多个elif，从而给程序开出更多的分支。

我们还可以让一个if结构嵌套在另一个if结构中：

------------------------------------------------------------------------

    i  = 5 
    if i > 1:                          # 该条件成立，执行内部的代码
        print("i bigger than 1")
        print("good")
    if i > 2:                          #嵌套的if结构，条件同样成立。
        print("i bigger than 2")
        print("even better")

------------------------------------------------------------------------

在进行完第一个if判断后，如果条件成立，那么程序依次运行，会遇到第二个if结构。程序将继续根据条件判断并决定是否执行。第二个后面的程序块相对于该if又缩进了四个空格，成为“小弟的小弟”。进一步缩进的程序隶属于内层的if。

总的来说，借着if结构，我们给程序带来了分支。根据条件的不同，程序将走上不同的道路，如图2-2所示。


![](../Images/image00107.jpeg)
图2-2　if选择结构
