# 4.1 轻松看对象

### 1．面向对象语言的来历

要想了解面向对象，就要先来了解**类**（Class）和**对象**（Object）。还记得面向过程中的函数和模块吗，它们提高了程序的可复用性。类和对象同样提高了程序的可复用性。除此之外，类和对象这两种语法结构还加强了程序模拟真实世界的能力。“模拟”，正是面向对象编程的核心。

面向对象范式可以追溯到Simula语言。克利斯登·奈加特是这门语言的两位作者之一。他被挪威国防部征召入伍，然后服务于挪威防务科学研究所。作为一名训练有素的数学家，克利斯登·奈加特一直在用电脑解决国防中的计算问题，例如核反应堆建设、舰队补给、后勤供应等。在解决这些问题的过程中，奈加特需要用电脑来模拟出真实世界的状况。比如说，如果发生一次核泄漏，会造成怎样的影响。奈加特发现，按照之前过程式的、指令式的编程方式，他很难用程序来表示真实世界中的个体。就拿一艘船来说，我们知道它会有一些数据，如高度、宽度、马力、吃水量等。它还会有一些动作，如移动、加速、加油、停泊等。这艘船就是一个个体。有些个体可以划为一类，如战列舰和航母都是军舰。有些个体之间有着包含关系，如一条船有船锚。

当人们讲故事时，会自然而然地描述来自真实世界的个体。但对于只懂0/1序列的计算机来说，它只会机械地执行一条条指令。奈加特希望，当他想要用计算机做模拟时，能像讲故事一样简单。他凭着自己在军事和民用方面的经验，知道这样的一种编程语言有着巨大的潜力。最终，他遇到了计算机专家奥利-约翰·达尔。达尔帮助奈加特把他的想法变成一门新颖的语言—Simula。这门语言的名字，正是奈加特朝思暮想的“模拟”[^(1)^](part0008.xhtml#ch1){#ch1-back}。

我们可以把面向对象看作是故事和指令之间的桥梁。程序员用一种故事式的编程语言描述问题，随后编译器会把这些程序翻译成机器指令。但在计算机发展的早期，这些额外的翻译工作会消耗太多的计算机资源。因此，面向对象的编程范式并不流行。一些纯粹的面向对象语言，也经常因为效率低下而受到诟病。

随着计算机性能的提高，效率问题不再是瓶颈。人们转而关注程序员的产量，开始发掘面向对象语言的潜力。在面向对象领域最先取得辉煌成功的是C++语言。比雅尼·斯特劳斯特鲁普在C语言的基础上增加面向对象的语法结构，创造出C++语言。C++杂糅了C语言特征，所以显得异常复杂。后来的Java语言向着更纯粹的面向对象范式靠拢，很快获得了商业上的成功。C++和Java一度成为最流行的编程语言。后来微软推出的C\#语言，以及苹果一直在支持的Objective-C语言，也都是典型的面向对象语言。

Python也是一门面向对象语言。它比Java还要历史悠久。只不过，Python允许程序员以纯粹的面向过程的方式来使用它，所以人们有时会忽视它那颗面向对象的心。Python的一条哲学理念是“一切皆对象”。无论是我们第3章看到的面向过程范式，还是未来会看到的函数式编程，其实都是特殊的对象模拟出的效果。因此，学习面向对象是学Python的一个关键环节。只有了解了Python的对象，我们才能看到这门语言的全貌。

### 2．类

说是要“找对象”，我们第一个看的却是个叫作“类”的语法结构。这里的类其实和我们日常生活中的“类”的概念差不多。日常生活中，我们把相近的东西归为一类，而且给这个类起一个名字。比如说，鸟类的共同属性是有羽毛，通过产卵生育后代。任何一只特别的鸟都是建立在鸟类的原型基础上的。

下面我们用Python语言来记录上面的想法，描述鸟类：

------------------------------------------------------------------------

    class Bird(object):
        feather = True
        reproduction  = "egg"

------------------------------------------------------------------------

在这里，我们用关键字class来定义一个类。类的名字就是鸟（Bird）。括号里有一个关键词object，也就是“东西”的意思，即某一个个体。在计算机语言中，我们把个体称为对象。一个类别下，可以有多个个体。鸟类就可以包括邻居老王养的金丝雀、天边正飞过的那只乌鸦，以及家里养的一只小黄鸡。

冒号和缩进说明了属于这个类的代码。在隶属于这个类别的程序块中，我们定义了两个量，一个用于说明鸟类有羽毛（feather），另一个用于说明鸟类的繁殖方式（reproduction），这两个量称为类的属性（attribute）。我们定义鸟类的方法很粗糙，鸟类只不过是“有毛能产蛋”的东西。要是生物学家看到了大概会暗自摇头，但我们毕竟迈出了模拟世界的第一步。

我们除了用数据性的属性来分辨类别外，有时也会根据这类东西能做什么事情来区分。比如说，鸟会移动。这样，鸟就和房屋的类别就区分开了。这些动作会带来一定的结果，比如移动导致位置的变化。这样的一些“行为”属性称为**方法**（method）。Python中，一般通过在类的内部定义函数来说明方法。

------------------------------------------------------------------------

    class Bird(object):
        feather = True
        reproduction = "egg"
        def chirp(self, sound):
             print(sound)

------------------------------------------------------------------------

我们给鸟类新增一个方法属性，就是表示鸟叫的方法chirp()。方法chirp()看起来很像一个函数。它的第一个参数是self，是为了在方法内部引用对象自身，我将在后面详细解释。需要强调的是，无论该参数是否用到，方法的第一个参数必须是用于指代对象自身的self。剩下的参数sound是为了满足我们的需求设计的，它代表了鸟叫的内容。方法chirp()会把sound打印出来。

### 3．对象

我们定义了类，但和函数定义一样，这还只是打造兵器的过程。为了使用这个利器，我们需要深入到对象的层面。通过调用类，我们可以创造出这个类下面的一个对象。比如说，我养了一只小鸡，叫summer。它是个对象，且属于鸟类。我们使用前面已经定义好的鸟类，产生这个对象：

------------------------------------------------------------------------

    summer = Bird()

------------------------------------------------------------------------

通过这一句创建对象，并说明summer是属于鸟类的一个对象。现在，我们就可以使用鸟类中已经写好的代码了。作为对象的summer将拥有鸟类的属性和方法。对属性的引用是通过**对象.属性**（object.attribute）的形式实现的。比如说：

------------------------------------------------------------------------

    print(summer.reproduction)      # 打印'egg'

------------------------------------------------------------------------

用上面的方式，我们得到summer所属类的繁殖方式。

此外，我们还可以调用方法，让summer执行鸟类允许的动作。比如：

------------------------------------------------------------------------

    summer.chirp("jijiji")          # 打印'jijiji'

------------------------------------------------------------------------

在调用方法时，我们只传递了一个参数，也就是字符串"jijiji"。这正是方法与函数有所区别的地方。尽管在定义类的方法时，我们必须加上这个self参数，但self只用能在类定义的内部，所以在调用方法时不需要对self传入数据。通过调用chirp()方法，我的summer就可以叫了。

到现在为止，描述对象的数据都存储于类的属性中。类属性描述了一个类的共性，比如鸟类都有羽毛。所有属于该类的对象会共享这些属性。比如说，summer是鸟类的一个对象，因此summer也有羽毛。当然，我们可以通过某个对象来引用某个类属性。

对于一个类下的全部个体来说，某些属性可能存在个体差异。比如说，我的summer是黄色的，但并非所有的鸟儿都是黄色的。再比如说人这个类。性别是某个人的一个性质，不是所有的人类都是男，或者都是女。这个性质的值随着对象的不同而不同。李雷是人类的一个对象，性别是男。韩美美也是人类的一个对象，性别是女。

因此，为了完整描述个体，除了共性的类属性外，我们还需要用于说明个性的对象属性。在类中，我们可以通过self来操作对象的属性。现在我们拓展Bird类：

------------------------------------------------------------------------

    class Bird(object):
        def chirp(self, sound):
            print(sound)
        def set_color(self, color):
            self.color = color

    summer = Bird()
    summer.set_color("yellow")
    print(summer.color)                      # 打印'yellow'

------------------------------------------------------------------------

在方法set\_color()中，我们通过self参数设定了对象的属性color。和类属性一样，我们能通过**对象.属性**的方式来操作对象属性。由于对象属性依赖于self，所以我们必须在某个方法内部才能操作类属性。因此，对象属性没办法像类属性一样，在类下方直接赋初值。

但Python还是提供了初始化对象属性的办法。Python定义了一系列**特殊方法**。特殊方法又被称为**魔法方法**（Magic Method）。特殊方法的方法名很特别，前后有两个下画线，比如\_\_init\_\_()、\_\_add\_\_()、\_\_dict\_\_()等。程序员可以在类定义中设定特殊方法。Python会以特定的方式来处理各个特殊方法。对于类的\_\_init\_\_()方法，Python会在每次创建对象时自动调用。因此，我们可以在\_\_init\_\_()方法内部来初始化对象属性：

------------------------------------------------------------------------

    class Bird(object):
        def __init__(self, sound):
            self.sound = sound
            print("my sound is:", sound)
        def chirp(self):
            print(self.sound)

    summer = Bird("ji")
    summer.chirp()                               # 打印'ji'

------------------------------------------------------------------------

在上面的类定义中，我们通过\_\_init\_\_()方法说明了这个类的初始化方式。每当对象建立时，比如创建summer对象时，\_\_init\_\_()方法就会被调用。它会设定sound这个对象属性。在后面的chirp()方法中，就可以通过self调用这一对象属性。除了设定对象属性外，我们还可以在\_\_init\_\_()中加入其他指令。这些指令会在创建对象时执行。在调用类时，类的后面可以跟一个参数列表。这里放入的数据将传给\_\_init\_\_()的参数。通过\_\_init\_\_()方法，我们可以在创建对象时就初始化对象属性。

除了操作对象属性外，self参数还有另外一个功能，就是能让我们在一个方法内部调用同一类的其他方法，比如：

------------------------------------------------------------------------

    class Bird(object):
        def chirp(self, sound):
            print(sound)

        def chirp_repeat(self, sound, n):
            for i in range(n):
                self.chirp(sound)

    summer = Bird()
    summer.chirp_repeat("ji", 10)             # 重复打印'ji'10次

------------------------------------------------------------------------

在方法chirp\_repeat()中，我们通过self调用了类中的另一个方法chirp()。
